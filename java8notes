Lambda 表达式作为参数时，其类型由它的目标类型推导得出，推导过程遵循如下规则：
	1. 如果只有一个可能的目标类型，由相应函数接口里的参数类型推导得出；
	2. 如果有多个可能的目标类型，由最具体的类型推导得出；
	3. 如果有多个可能的目标类型且最具体的类型不明确，则需人为指定类型。

三定律 
如果对默认方法的工作原理，特别是在多重继承下的行为还没有把握，如下三条简单的定 律可以帮助大家。
 1. 类胜于接口。如果在继承链中有方法体或抽象的方法声明，那么就可以忽略接口中定义 的方法。
 2. 子类胜于父类。如果一个接口继承了另一个接口，且两个接口都定义了一个默认方法， 那么子类中定义的方法胜出。 
3. 没有规则三。如果上面两条规则不适用，子类要么需要实现该方法，要么将该方法声明 为抽象方法。 其中第一条规则是为了让代码向后兼容。

一些操作在有序的流上开销更大，调用 unordered 方法消除这种顺序就能解决该问题。大 多数操作都是在有序流上效率更高，比如 filter、map 和 reduce 等。

使用并行流时，forEach 方法不能保证元素是 按顺序处理的。如果需要保证按顺序处理，应该使用 forEachOrdered 方法。

使用 toCollection，用定制的集合收集元素 
stream.collect(toCollection(TreeSet::new));

Function<T, R>
Function<Artist, Long> getCount = artist -> artist.getMembers().count(); 

Java 8 引入了一个新方法 computeIfAbsent，该方法接受一个 Lambda 表达式，值不存在时
使用该 Lambda 表达式计算新值。


数据分块

数据分组

字符串

组合收集器
